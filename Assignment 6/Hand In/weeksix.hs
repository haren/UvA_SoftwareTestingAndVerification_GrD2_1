-- Software verification and testing
-- Assignment for Week 6, Date: 13-10-2013
-- Group D2_1
-- Cigdem Aytekin 10463135,
-- Jorryt Jan Dijkstra 10462015,
-- 10628185,
-- Lukasz Harezlak, 10630171



module Main

where
import Data.List
import Data.Bits
import Control.Monad
import System.Random
import System.TimeIt
import Week6

-- cabal install timeit

getRandomIntInRange :: Int -> Int -> IO Int
getRandomIntInRange x y = getStdRandom(randomR(x,y))

getRandomIntegerInRange :: Integer -> Integer -> IO Integer
getRandomIntegerInRange x y = getStdRandom(randomR(x,y))

getRandomIntsInRange :: Int -> Int -> Int -> IO [Int]
getRandomIntsInRange 0 _ _ = return []
getRandomIntsInRange n x y = do
    f <- getRandomIntInRange x y
    fs <- getRandomIntsInRange (n-1) x y
    return (f : fs)

-- Answer 1: Implement the exM function.
-- Improved exM function using right to left binary method.
-- Time spent: about three hours.
exM' :: Integer -> Integer -> Integer -> Integer
exM' base expo modulus  = rightToLeftBinary 1 base expo modulus
            where rightToLeftBinary :: Integer -> Integer -> Integer -> Integer -> Integer
                  rightToLeftBinary result base expo modulus
                    | (expo > 0) = rightToLeftBinary newResult newBase newExponent modulus -- recurse until expo is 0
                    | otherwise = result
                    where newResult = if ((.&.) expo 1 == 1) -- Check for odd number
                                      then mod (result * base) modulus -- Intermediate result
                                      else result
                          newExponent = shiftR expo 1 -- Bit shift (dev by 2 basically)
                          newBase = mod (base * base) modulus

-- ghc -o weeksix weeksix.hs for preventing interpreter out of memory
main :: IO ()
main = testModularExponentiationPerformance


-- Answer 2: Check that your implementation is 
-- more efficient than expM by running number of tests 
-- and documenting the results.
-- Time spent: about an hour

-- Test for modular exponentiation
testModularExponentiationPerformance :: IO ()
testModularExponentiationPerformance = do
  amountToTest <- getRandomIntInRange 10 100
  bases <- getRandomIntsInRange amountToTest 10000000 100000000
  exponents <- getRandomIntsInRange amountToTest 10000000 100000000
  moduluses <- getRandomIntsInRange amountToTest 10 100000000
  
  putStrLn ("Starting " ++ show amountToTest ++ " tests of different modulo exponentiations")
  
  testExponentialModulus' bases exponents moduluses
  where
        testExponentialModulus' :: [Int] -> [Int] -> [Int] -> IO()
        testExponentialModulus' [] _ _ = putStrLn "End"
        testExponentialModulus' (x:xs) (y:ys) (z:zs) = do
          let x' = toInteger x
              y' = toInteger y
              z' = toInteger z
              
          putStrLn("-- Test for input: " ++ show x' ++ "^" ++ show y' ++ " modulo " ++ show z)
          
          timeIt $ putStrLn ("ExpM: " ++ show (expM x' y' z'))
          timeIt $ putStrLn ("ExM': " ++ show (exM' x' y' z'))
          
          putChar '\n'
          testExponentialModulus' xs ys zs

-- Note: There are three more versions of exM, these can be found 
-- in the Prep Work directories of Zarina, Lukasz and Cigdem 
-- They are also faster than expM.



-- Answer 3: Write a function composites :: [Integer] that generates
-- the infinite list of composite natural numbers.
-- Time spent: about 15 minutes.
composites :: [Integer]
composites = [ n | n <- [4..], not $ isPrime n ]

carmichael :: [Integer]
carmichael = [ (6*k+1)*(12*k+1)*(18*k+1) | k <- [2..], isPrime (6*k+1), isPrime (12*k+1), isPrime (18*k+1) ]


-- Answer 4: Use the list of composite numbers to test Fermat's primality check.
-- The first composite integer to be found prime was 4

-- Answer 5: Use the list generated by the carmichael function for a further 
-- test of Fermat's primality check.
-- Time spent: about an hour for both 4 and 5.
testFermat :: IO ()
testFermat = do
  accuracy <- getRandomIntInRange 10 100 -- amount of tests to do for each primality check (determines the accuracy obviously)
  amount <- getRandomIntInRange 1000 10000 -- amount of numbers to test of the composites and carmichael numbers
  carmichaelAmount <- getRandomIntInRange 100 500 -- these are huge so they take a long time, use a different amount
  staticTest <- prime_test_F 1
  staticTest2 <- prime_test_F 2
  staticTest3 <- prime_test_F 3
  
  putStrLn "Static tests:"
  putStrLn ("1: " ++ show staticTest)
  putStrLn ("2: " ++ show staticTest2)
  putStrLn ("3: " ++ show staticTest3)
  putStrLn ("Testing the numbers from the first " ++ show amount ++ " composite and the carmichael numbers for primality")
  dynamicTest <- repeatFermatCheck accuracy amount composites
  carmichaelTest <- repeatFermatCheck accuracy carmichaelAmount carmichael
  
  putStrLn ("Composite numbers found as false positives: " ++ show dynamicTest)
  putStrLn ("Carmichael numbers found as false positives: " ++ show carmichaelTest)
  putStrLn "End of test"

  where
        -- Loop/repeat the fermat test for different accuracies (which is a parameter that gets decreased by 1)
        repeatFermatCheck 0 n (x:xs) = return []
        repeatFermatCheck a n xs = do
          result <- testFermat' a n xs
          testTail <- repeatFermatCheck (a-1) n xs
          return ((a, result) : testTail)

        testFermat' _ 0 _ = return []
        testFermat' a n (x:xs) = do
          result <- primeF a x

          putStrLn(show x ++ ": " ++ show result)

          testTail <- testFermat' a (n-1) xs
          
          if result
          then return (x : testTail)
          else return testTail
-- From Wikipedia:
-- Carmichael numbers are important because they pass the Fermat primality test 
-- but are not actually prime. Since Carmichael numbers exist, this primality 
-- test cannot be relied upon to prove the primality of a number, although it 
-- can still be used to prove that a number is composite.
-- A few carmichael numbers:
-- [294409,56052361,118901521,172947529,216821881,228842209]



-- Answer 6: Use the list from the previous exercise to test the Miller-Rabin primality
-- check. What do you find?
-- Time spent: about an hour

-- Miller Rabin test is more accurate for carmichael numbers
testMillerRabin :: IO ()
testMillerRabin = do
  accuracy <- getRandomIntInRange 10 100 -- amount of tests to do for each primality check (determines the accuracy obviously)
  amount <- getRandomIntInRange 30 100
  putStrLn ("Testing MR test with " ++ show amount ++ " carmichael numbers, with initial accuracy " ++ show accuracy ++ " and loosening it over time")
  results <- repeatMillerCheck accuracy (take amount carmichael)
  putStrLn("Results of false positives (format: (accuracy, [prime numbers]):\n " ++ show results)
  where 
        -- Loop for the miller check with decreasing accuracies
        repeatMillerCheck 0 (x:xs) = return []
        repeatMillerCheck a xs = do
          -- Do the check over the whole xs list
          results <- mapM (\x -> primeMR a x) xs
          let zippedResults = zip xs results
              outputResults = map (fst) (filter (\(_,y) -> y) zippedResults)
          mapM_ (\(x,y) -> putStrLn $ show x ++ ": " ++ show y) zippedResults

          testTail <- repeatMillerCheck (a-1) xs
          return ((a,outputResults) : testTail)


-- Answer 7: Use the Miller-Rabin primality check to discover some large Mersenne
-- primes. The largest Mersenne prime we could find was: 9689, i.e. (2^9689 - 1)
-- Time spent: about half an hour

-- Parameter is the amount of primes to consider
generateMersennePrimes :: Int -> IO [Integer]
generateMersennePrimes primeThreshold = do
  let mersennes = [ ((2^p)-1) | p <- take primeThreshold primes ]
  results <- filterM (\x -> primeMR 1 x) mersennes
  return results




-- Answer 8: Answer to the bonus question
-- Time spent: about an hour

-- Generate a co prime of z within the range of x and y
generateCoPrimeInRange :: Integer -> Integer -> Integer -> IO Integer
generateCoPrimeInRange x y z = do
  i <- getRandomIntegerInRange x y
  if ((gcd i z) /= 1)
  then generateCoPrimeInRange x y z
  else return i

-- Stolen from Week6.hs, but changed the parameter sequence (which is more logical to me) plus using the faster/improved exM' function
rsa_encode' :: Integer -> Integer -> Integer -> Integer 
rsa_encode' n e =  \m -> exM' m e n

rsa_decode' :: Integer -> Integer -> Integer -> Integer 
rsa_decode' n d = \c -> exM' c d n

generatePublicKeyPair :: IO ((Integer, Integer), Integer)
generatePublicKeyPair = do
  p <- generateUniqueLargeRandomPrime 0 -- 0 will be ignored
  q <- generateUniqueLargeRandomPrime p
  let n = p * q
      phi = (p - 1) * (q - 1)
  e <- generateCoPrimeInRange 2 (n - 1) phi  
  return ((n, e), phi)

generatePrivateKey :: Integer -> Integer -> Integer
generatePrivateKey e phi = invM e phi

setupRSA :: IO ((Integer, Integer), Integer)
setupRSA = do
  publicPair <- generatePublicKeyPair
  let privateKey = generatePrivateKey (snd (fst publicPair)) (snd publicPair) -- generate a private key based on e and phi
  
  -- Verbose
  putStrLn("Public key modulus:  " ++ (show $ fst (fst publicPair)))
  putStrLn("Public key exponent: " ++ (show $ snd (fst publicPair)))
  putStrLn("Private key exponent:" ++ (show privateKey) ++ "\n\n")
  
  return (fst publicPair, privateKey) -- first from the public pair as we do not need phi anymore

generateUniqueLargeRandomPrime :: Integer -> IO Integer
generateUniqueLargeRandomPrime otherPrime = do
  p <- getRandomIntegerInRange 10000000000000000000000000000000000000000000000 10900000000000000000000000000000000000000000000 -- large enough? :)
  result <- primeMR 10 (fromIntegral p) -- 10 tests is considered acceptable by me
  if ((not) result || p == otherPrime) -- make sure the result is a prime and NOT equal to the other prime provided
  then generateUniqueLargeRandomPrime otherPrime  -- repeat the process for a unique prime
  else return p

testRSA :: IO Bool
testRSA = do
  rsa <- setupRSA -- generates rsa public key pair and a private key
  amountToTest <- getRandomIntInRange 100 1000 -- random amount to test for le fun

  let publicPair = fst rsa -- returns a tuple with (n, e)
      privateKey = snd rsa -- returns d
  
      -- Static test
      msg = 133333333337
      encodeOutput = rsa_encode' (fst publicPair) (snd publicPair) msg
      decodeOutput = rsa_decode' (fst publicPair) privateKey encodeOutput

  -- Dynamic random test
  testResults <- testRSA' amountToTest publicPair privateKey
  return (msg == decodeOutput && testResults)

  -- Tests whether random input which gets encoded is equal to the encoded version being decoded, using the public exponent for encryption and the private exponent for decryption
  where
      testRSA' :: Int -> (Integer, Integer) -> Integer -> IO Bool
      testRSA' 0 _ _ = return True
      testRSA' n publicPair privateKey = do
        msg <- getRandomIntegerInRange 0 ((fst publicPair) - 1)
      
        let encodeOutput = rsa_encode' (fst publicPair) (snd publicPair) msg
            decodeOutput = rsa_decode' (fst publicPair) privateKey encodeOutput
            
        testTail <- testRSA' (n-1) publicPair privateKey

        return (msg == decodeOutput && testTail)