module Lab6Cigdem

where
import Data.List
import System.Random
import Week6
import Lab6



-- For a given y, this function finds the maximum of 2^i's
-- for which 2^i is less than or equal to y. For example, for  
-- y = 33, it will return 32, for 18, it will return 16, etc.

findPowOfTwo :: Integer -> Integer
findPowOfTwo y = t 
        where   t = 2^upperBound 
        --  t = maximum [ 2^i | i <- [0..upperBound], (2^i <= y)]
                log2YFloat  = logBase 2 (fromIntegral y)
                upperBound    = floor log2YFloat


findPowOfTwos :: Integer -> [Integer]
findPowOfTwos   0 = []
findPowOfTwos   1 = [1]
findPowOfTwos   n = a : findPowOfTwos (n-a)
        where a = findPowOfTwo n
     

remPowOfTwo :: Integer -> Integer -> Integer
remPowOfTwo a b = a - b

powerOf  :: Integer -> Integer -> Integer
powerOf x y = x ^ y
             
modOf :: Integer -> Integer -> Integer
modOf n x = x `mod` n             
             
-- Answer 1
   
exMCigdem3 :: Integer -> Integer -> Integer -> Integer
exMCigdem3
     x y n   = modOf  n (product (map (modOf n) (map (powerOf (x `mod` n )) [i | i <- xs])))
    where   xModn   = x `mod` n 
            xs      = findPowOfTwos y
            
-- Answer 2: for the data (56777812322 ^ 12333221) mod  6, 
-- expM calculates it in 41.96 seconds and exMCigdem3
-- calculates it in 0,45 secs. This is 93 times faster
            

-- Answer 3 : Write a function composites :: [Integer] that 
-- generates the infinite list of composite natural numbers.

composites :: [Integer]
composites = sieve2 [4..]

sieve2 [] = []
sieve2 (n:ns) 
        | not(isPrime n) = n : sieve2 ns
        | otherwise      = sieve2 ns

    
-- Answer 4 : Use the list of composite numbers to test Fermat's primality check. What is the
-- least composite number that you can find that fools the check, for testF k with
-- k = 1; 2; 3 ? What happens if you increase k?
   
 
-- findFalsePositives uses prime_test_F for Fermat's primality 
-- check
findFalsePositives :: [Integer] -> IO [Integer]
findFalsePositives  [] = return []
findFalsePositives  [i] = do
                        myBool <- prime_test_F i
                        if (myBool) 
                           then return [i]
                           else return []
findFalsePositives (x:xs)   = do
                            y <- findFalsePositives [x]
                            ys <- findFalsePositives xs
                            return ( y ++ ys)
                             
-- findFalsePositivesAdv uses a better version of Fermat's 
-- primality check, namely the primeF function                

findFalsePositivesAdv :: [Integer] -> IO [Integer]
findFalsePositivesAdv  [] = return []
findFalsePositivesAdv  [i] = do
                        myBool <- primeF 130 i
                        if (myBool) 
                           then return [i]
                           else return []
findFalsePositivesAdv (x:xs)   = do
                            y <- findFalsePositivesAdv [x]
                            ys <- findFalsePositivesAdv xs
                            return ( y ++ ys)



-- Answer 5: Use the list generated by the following function 
-- (carmichael) for a further test of Fermat's primality check.

-- From Wikipedia:
-- Carmichael numbers are important because they pass the Fermat primality test 
-- but are not actually prime. Since Carmichael numbers exist, 
-- this primality test cannot be relied upon to prove the 
-- primality of a number, although it can still be used to 
-- prove a number is composite.

carmichaelIOTest :: IO Int
carmichaelIOTest = do
                    ys <- findFalsePositivesAdv (take 100 carmichael) 
                    let lenOfYs = length ys
                    return lenOfYs    
                         

-- [294409,56052361,118901521,172947529,216821881,228842209]



